// Generated by CurlyCS 0.01.1
(function() {
  var BALANCED_PAIRS, BLOCK_NO_TERM, EXPRESSION_CLOSE, EXPRESSION_END, EXPRESSION_START, INVERSES, SINGLE_CLOSERS, SINGLE_LINERS, j, left, len, ref, rite,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  exports.Rewriter = (function() {
    function _Class() {}

    _Class.prototype.rewrite = function(tokens1) {
      this.tokens = tokens1;
      this.removeLeadingNewlines();
      this.closeOpenCalls();
      this.closeOpenIndexes();
      this.tagPostfixIFs();
      this.tagObjectsAndClasses();
      this.addTerminators();
      this.fixGeneratedTokens();
      return this.tokens;
    };

    _Class.prototype.scanTokens = function(block) {
      var i, token, tokens;
      tokens = this.tokens;
      i = 0;
      while (token = tokens[i]) {
        i += block.call(this, token, i, tokens);
      }
      return true;
    };

    _Class.prototype.detectEnd = function(i, condition, action) {
      var levels, ref, ref1, token, tokens;
      tokens = this.tokens;
      levels = 0;
      while (token = tokens[i]) {
        if (levels === 0 && condition.call(this, token, i)) {
          return action.call(this, token, i);
        }
        if (!token || levels < 0) {
          return action.call(this, token, i - 1);
        }
        if (ref = token[0], indexOf.call(EXPRESSION_START, ref) >= 0) {
          levels += 1;
        } else if (ref1 = token[0], indexOf.call(EXPRESSION_END, ref1) >= 0) {
          levels -= 1;
        }
        i += 1;
      }
      return i - 1;
    };

    _Class.prototype.removeLeadingNewlines = function() {
      var i, j, len, ref, tag;
      ref = this.tokens;
      for (i = j = 0, len = ref.length; j < len; i = ++j) {
        tag = ref[i][0];
        if (tag !== 'TERMINATOR') {
          break;
        }
      }
      if (i) {
        return this.tokens.splice(0, i);
      }
    };

    _Class.prototype.closeOpenCalls = function() {
      var action, condition;
      condition = function(token, i) {
        var ref;
        return ((ref = token[0]) === ')' || ref === 'CALL_END') || token[0] === 'BLOCK_END' && this.tag(i - 1) === ')';
      };
      action = function(token, i) {
        return this.tokens[token[0] === 'BLOCK_END' ? i - 1 : i][0] = 'CALL_END';
      };
      return this.scanTokens(function(token, i) {
        if (token[0] === 'CALL_START') {
          this.detectEnd(i + 1, condition, action);
        }
        return 1;
      });
    };

    _Class.prototype.closeOpenIndexes = function() {
      var action, condition;
      condition = function(token, i) {
        var ref;
        return (ref = token[0]) === ']' || ref === 'INDEX_END';
      };
      action = function(token, i) {
        return token[0] = 'INDEX_END';
      };
      return this.scanTokens(function(token, i) {
        if (token[0] === 'INDEX_START') {
          this.detectEnd(i + 1, condition, action);
        }
        return 1;
      });
    };

    _Class.prototype.addTerminators = function() {
      return this.scanTokens(function(token, i, tokens) {
        var ref, ref1, termToken;
        if (token[0] === 'BLOCK_END' && tokens[i + 1] && !((ref = tokens[i + 1][0], indexOf.call(SINGLE_CLOSERS, ref) >= 0) || (ref1 = tokens[i + 1][0], indexOf.call(BLOCK_NO_TERM, ref1) >= 0))) {
          termToken = ['TERMINATOR', ';'];
          termToken.explicit = true;
          tokens.splice(i + 1, 0, termToken);
          return 2;
        }
        return 1;
      });
    };

    _Class.prototype.tagObjectsAndClasses = function() {
      return this.scanTokens(function(token, i, tokens) {
        var clsEnd, clsStart, found, foundCls, ref, ref1, ref2, stack, stackIdx, tag, tok;
        clsStart = clsEnd = null;
        foundCls = false;
        tag = token[0];
        if (tag === ':') {
          if (tokens[i - 1][1] === '{' && tokens[i + 1][1] === '}') {
            if (tokens[i - 1][0] === 'BLOCK_START' && tokens[i + 1][0] === 'BLOCK_END') {
              tokens[i - 1][0] = 'OBJ_START';
              tokens[i + 1][0] = 'OBJ_END';
              tokens.splice(i, 1);
              return 1;
            }
          }
          found = false;
          stackIdx = i;
          stack = [];
          while (!found && (tok = tokens[--stackIdx])) {
            switch (tok[1]) {
              case '}':
                stack.push(tok);
                break;
              case '{':
                if (stack.length) {
                  stack.pop();
                } else {
                  if (tok[0] === 'BLOCK_START') {
                    tok[0] = 'OBJ_START';
                    if (tokens[stackIdx - 1] && ((ref = tokens[stackIdx - 1][0]) === 'CLASS' || ref === 'EXTENDS') || tokens[stackIdx - 2] && ((ref1 = tokens[stackIdx - 2][0]) === 'CLASS' || ref1 === 'EXTENDS')) {
                      foundCls = true;
                      ref2 = this.blocking(), clsStart = ref2[0], clsEnd = ref2[1];
                      tokens.splice(stackIdx, 0, clsStart);
                      i += 1;
                    }
                  }
                  found = true;
                  break;
                }
            }
          }
          found = false;
          stackIdx = i;
          stack = [];
          while (!found && (tok = tokens[++stackIdx])) {
            switch (tok[1]) {
              case '{':
                stack.push(tok);
                break;
              case '}':
                if (stack.length) {
                  stack.pop();
                } else {
                  if (tok[0] === 'BLOCK_END') {
                    tok[0] = 'OBJ_END';
                    if (foundCls) {
                      stackIdx += 1;
                      tokens.splice(stackIdx, 0, clsEnd);
                    }
                  }
                  found = true;
                  break;
                }
            }
          }
        }
        if (foundCls) {
          return 2;
        } else {
          return 1;
        }
      });
    };

    _Class.prototype.fixGeneratedTokens = function() {
      return this.scanTokens(function(token, i, tokens) {
        var column, line, nextLocation, prevLocation, ref, ref1;
        if (token[2]) {
          return 1;
        }
        if (!(token.generated || token.explicit)) {
          return 1;
        }
        if (token[0] === 'OBJ_START' && (nextLocation = (ref = tokens[i + 1]) != null ? ref[2] : void 0)) {
          line = nextLocation.first_line, column = nextLocation.first_column;
        } else if (prevLocation = (ref1 = tokens[i - 1]) != null ? ref1[2] : void 0) {
          line = prevLocation.last_line, column = prevLocation.last_column;
        } else {
          line = column = 0;
        }
        token[2] = {
          first_line: line,
          first_column: column,
          last_line: line,
          last_column: column
        };
        return 1;
      });
    };

    _Class.prototype.tagPostfixIFs = function() {
      var action, condition, original;
      original = null;
      condition = function(token, i) {
        var prevTag, tag;
        tag = token[0];
        prevTag = this.tokens[i - 1][0];
        return tag === 'TERMINATOR' || (tag === 'BLOCK_START' && indexOf.call(SINGLE_LINERS, prevTag) < 0);
      };
      action = function(token, i) {
        if (token[0] !== 'BLOCK_START' || (token.generated && !token.fromThen)) {
          return original[0] = 'POST_' + original[0];
        }
      };
      return this.scanTokens(function(token, i) {
        if (token[0] !== 'IF') {
          return 1;
        }
        original = token;
        this.detectEnd(i + 1, condition, action);
        return 1;
      });
    };

    _Class.prototype.blocking = function(origin) {
      var blkEnd, blkStart;
      blkStart = ['BLOCK_START', '{'];
      blkEnd = ['BLOCK_END', '}'];
      if (origin) {
        blkStart.generated = blkEnd.generated = true;
        blkStart.origin = blkEnd.origin = origin;
      } else {
        blkStart.explicit = blkEnd.explicit = true;
      }
      return [blkStart, blkEnd];
    };

    _Class.prototype.tag = function(i) {
      var ref;
      return (ref = this.tokens[i]) != null ? ref[0] : void 0;
    };

    return _Class;

  })();

  BALANCED_PAIRS = [['(', ')'], ['[', ']'], ['{', '}'], ['BLOCK_START', 'BLOCK_END'], ['OBJ_START', 'OBJ_END'], ['CALL_START', 'CALL_END'], ['PARAM_START', 'PARAM_END'], ['INDEX_START', 'INDEX_END'], ['STRING_START', 'STRING_END'], ['REGEX_START', 'REGEX_END']];

  exports.INVERSES = INVERSES = {};

  EXPRESSION_START = [];

  EXPRESSION_END = [];

  for (j = 0, len = BALANCED_PAIRS.length; j < len; j++) {
    ref = BALANCED_PAIRS[j], left = ref[0], rite = ref[1];
    EXPRESSION_START.push(INVERSES[rite] = left);
    EXPRESSION_END.push(INVERSES[left] = rite);
  }

  EXPRESSION_CLOSE = ['CATCH', 'THEN', 'ELSE', 'FINALLY'].concat(EXPRESSION_END);

  SINGLE_LINERS = ['ELSE', '->', '=>', 'TRY', 'FINALLY', 'THEN'];

  SINGLE_CLOSERS = ['TERMINATOR', 'CATCH', 'FINALLY', 'ELSE', 'BLOCK_END', 'LEADING_WHEN'];

  BLOCK_NO_TERM = [')', ']', '}', 'CALL_END', 'PARAM_END', 'INDEX_END', 'OBJ_END', 'STRING_END', 'REGEX_END', ',', '?', '+', '-', 'MATH', '**', 'SHIFT', 'COMPARE', 'LOGIC', 'RELATION'];

}).call(this);
